<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Inspector - RFC 9553 Contact Management System</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .database-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .database-title {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected { background-color: #27ae60; }
        .status-error { background-color: #e74c3c; }
        .status-loading { background-color: #f39c12; }
        
        .database-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .info-card {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
        }
        
        .info-label {
            font-weight: bold;
            color: #34495e;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .data-table th {
            background-color: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
        }
        
        .data-table td {
            padding: 10px;
            border-bottom: 1px solid #bdc3c7;
            vertical-align: top;
        }
        
        .data-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .json-data {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .btn {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn-danger {
            background-color: #e74c3c;
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        
        .error {
            background-color: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: #3498db;
            color: white;
            padding: 20px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .shared-db-info {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin: 10px 0;
        }

        .archive-status {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }

        .contact-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            margin: 2px;
        }

        .badge-owned { background-color: #27ae60; }
        .badge-received { background-color: #3498db; }
        .badge-shared { background-color: #9b59b6; }
        .badge-archived { background-color: #95a5a6; }
    </style>
</head>
<body>
        <div class="header">
            <h1>üîç Database Inspector - RFC 9553 Contact Management System</h1>
            <div class="header-controls">
                <button id="refresh-btn" onclick="refreshAllData()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    üîÑ Force Refresh
                </button>
                <button onclick="exportAllData()" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    üì§ Export All
                </button>
                <span id="user-info" style="margin-right: 15px; font-weight: bold; color: #333;"></span>
                <button onclick="logout()" style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Logout</button>
            </div>
        </div>    <div class="controls">
        <button class="btn" onclick="refreshAllData()">üîÑ Refresh All Data</button>
        <button class="btn" onclick="exportAllData()">üìä Export All Data</button>
        <button class="btn" onclick="clearLocalArchives()">üóÇÔ∏è Clear Local Data</button>
        <button class="btn" onclick="location.href='../index.html'">üè† Back to Contact Manager</button>
    </div>

    <div id="loginSection">
        <div class="database-section">
            <h2>üîê Login Required</h2>
            <p>Please log in to inspect databases:</p>
            <input type="text" id="usernameInput" placeholder="Username" style="padding: 10px; margin: 10px; width: 200px;">
            <input type="password" id="passwordInput" placeholder="Password" style="padding: 10px; margin: 10px; width: 200px;">
            <button class="btn" onclick="loginAndInspect()">Login & Inspect</button>
        </div>
    </div>

    <div id="inspectorContent" style="display: none;">
        <div id="summarySection"></div>
        <div id="localStorageSection"></div>
        <div id="databaseSections"></div>
    </div>

    <script src="../lib/userbase.js"></script>
    <script>
        let currentUser = null;
        let allDatabaseData = {};
        let discoveredDatabases = [];

        // Updated database configurations for RFC 9553 Contact Management System
        const DATABASE_CONFIGS = {
            // Main user contacts database (RFC 9553 vCard 4.0)
            contacts: {
                title: 'üìá Contacts Database',
                description: 'User\'s contacts in RFC 9553 vCard 4.0 format (shareable with other users)',
                getName: (user) => `contacts`,
                isOwned: true,
                category: 'contacts'
            },
            
            // User settings and distribution lists
            settings: {
                title: '‚öôÔ∏è User Settings',
                description: 'User preferences, distribution lists, and application settings',
                getName: (user) => `settings`,
                isOwned: true,
                category: 'settings'
            },

            // Activity log for audit trail
            activity: {
                title: 'ÔøΩ Activity Log',
                description: 'Contact management activity and audit trail',
                getName: (user) => `activity`,
                isOwned: true,
                category: 'activity'
            },

            // Shared contact metadata (user-specific states for shared contacts)
            sharedContactMetadata: {
                title: 'ÔøΩ Shared Contact Metadata',
                description: 'User-specific metadata for shared contacts (archive states, usage tracking)',
                getName: (user) => `shared-contact-metadata`,
                isOwned: true,
                category: 'metadata'
            }
        };

        async function loginAndInspect() {
            const username = document.getElementById('usernameInput').value;
            const password = document.getElementById('passwordInput').value;

            if (!username || !password) {
                alert('Please enter both username and password');
                return;
            }

            try {
                await userbase.init({ appId: '77e5016f-285d-4678-a31a-3718479a638a' });
                
                const session = await userbase.signIn({
                    username: username,
                    password: password
                });

                currentUser = username;
                document.getElementById('loginSection').style.display = 'none';
                document.getElementById('inspectorContent').style.display = 'block';

                await inspectAllDatabases();

            } catch (error) {
                console.log('Database Inspector - Login failed:', error);
                
                // Handle "Already signed in" error
                if (error.message.includes('Already signed in')) {
                    console.log('Detected session desync, attempting to clear and retry...');
                    try {
                        await userbase.signOut();
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const user = await userbase.signIn({ username, password });
                        console.log('Retry login successful:', user);
                        
                        currentUser = username;
                        document.getElementById('loginSection').style.display = 'none';
                        document.getElementById('inspectorContent').style.display = 'block';
                        await inspectAllDatabases();
                        
                    } catch (retryError) {
                        console.log('Retry login failed:', retryError);
                        alert('Login failed: ' + retryError.message);
                    }
                } else {
                    alert('Login failed: ' + error.message);
                }
            }
        }

        async function inspectAllDatabases() {
            if (!currentUser) {
                console.error('No current user');
                return;
            }

            // Reset data
            allDatabaseData = {};
            discoveredDatabases = [];

            // Show loading
            document.getElementById('summarySection').innerHTML = '<div class="loading">Loading all databases...</div>';
            document.getElementById('databaseSections').innerHTML = '';

            let totalDatabases = 0;
            let totalItems = 0;
            let connectedDatabases = 0;
            let errorDatabases = 0;

            // First, discover all available databases
            try {
                const databasesResponse = await userbase.getDatabases();
                discoveredDatabases = databasesResponse.databases || [];
                console.log('Discovered databases:', discoveredDatabases);
            } catch (error) {
                console.error('Error discovering databases:', error);
                discoveredDatabases = [];
            }

            // Inspect each predefined database type
            for (const [key, config] of Object.entries(DATABASE_CONFIGS)) {
                totalDatabases++;
                
                try {
                    const databaseName = config.getName(currentUser);
                    console.log(`Inspecting database: ${databaseName}`);
                    
                    let data;
                    if (config.useLocalStorage) {
                        // Handle localStorage-based databases (synchronous)
                        data = inspectLocalStorageDatabase(databaseName, config);
                    } else {
                        // Handle regular Userbase databases (asynchronous)
                        data = await inspectDatabase(databaseName, config.isOwned);
                    }
                    
                    if (data.exists) {
                        allDatabaseData[key] = {
                            config: config,
                            data: data,
                            status: 'connected'
                        };
                        connectedDatabases++;
                        totalItems += data.itemCount;
                    } else {
                        // Don't count system databases as errors when they're expected to be unavailable
                        const isExpectedUnavailable = (config.category === 'system' && !config.isOwned);
                        
                        allDatabaseData[key] = {
                            config: config,
                            data: data,
                            status: isExpectedUnavailable ? 'unavailable' : 'error',
                            error: data.error || 'Database does not exist'
                        };
                        
                        if (!isExpectedUnavailable) {
                            errorDatabases++;
                        }
                    }
                    
                } catch (error) {
                    console.warn(`Failed to inspect ${key} database:`, error);
                    allDatabaseData[key] = {
                        config: config,
                        data: null,
                        status: 'error',
                        error: error.message
                    };
                    errorDatabases++;
                }
            }

            // Inspect shared databases (these are dynamically created)
            const sharedDatabases = discoveredDatabases.filter(db => 
                db.databaseName.startsWith('shared-contact-') && 
                db.databaseName.endsWith(`-${currentUser}`)
            );

            for (const sharedDb of sharedDatabases) {
                totalDatabases++;
                const key = `shared-${sharedDb.databaseName}`;
                
                try {
                    const data = await inspectSharedDatabase(sharedDb);
                    
                    if (data.exists) {
                        allDatabaseData[key] = {
                            config: {
                                title: `ü§ù Shared: ${data.senderName || 'Unknown'}`,
                                description: `Contact shared from ${data.senderName || 'unknown user'}`,
                                category: 'shared'
                            },
                            data: data,
                            status: 'connected'
                        };
                        connectedDatabases++;
                        totalItems += data.itemCount;
                    } else {
                        errorDatabases++;
                    }
                } catch (error) {
                    console.warn(`Failed to inspect shared database ${sharedDb.databaseName}:`, error);
                    errorDatabases++;
                }
            }

            // Update summary
            updateSummary(totalDatabases, connectedDatabases, errorDatabases, totalItems);

            // Show local storage data
            updateLocalStorageSection();

            // Render all database sections
            renderDatabaseSections();
        }

        async function inspectDatabase(databaseName, isOwned = true) {
            console.log(`Inspecting database: ${databaseName} (owned: ${isOwned})`);
            
            if (!isOwned) {
                // For shared databases, check if they exist in discovered list
                const foundDb = discoveredDatabases.find(db => db.databaseName === databaseName);
                
                if (!foundDb) {
                    return {
                        databaseName: databaseName,
                        items: [],
                        itemCount: 0,
                        isOwned: isOwned,
                        exists: false,
                        error: 'Shared database not available (normal if no one shared with you)'
                    };
                }
            }
            
            return new Promise((resolve, reject) => {
                let resolved = false;
                const items = [];
                
                // Add timeout to ensure we get a response
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        console.log(`‚è∞ Database ${databaseName} inspection timed out, returning current items:`, items.length);
                        resolve({
                            databaseName: databaseName,
                            items: items,
                            itemCount: items.length,
                            isOwned: isOwned,
                            exists: items.length > 0 || isOwned, // Assume owned databases exist even if empty
                            error: items.length === 0 && !isOwned ? 'No items found' : null
                        });
                    }
                }, 5000); // 5 second timeout
                
                const options = {
                    databaseName: databaseName,
                    changeHandler: (dbItems) => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            
                            console.log(`üìä Database ${databaseName} changeHandler received:`, dbItems ? dbItems.length : 0, 'items');
                            if (dbItems && dbItems.length > 0) {
                                console.log(`üìã First item preview (${databaseName}):`, {
                                    itemId: dbItems[0].itemId,
                                    item: dbItems[0].item,
                                    keys: Object.keys(dbItems[0].item || {}),
                                    type: typeof dbItems[0].item
                                });
                            } else {
                                console.log(`‚ùå No items found in ${databaseName} - database may be empty`);
                            }
                            
                            resolve({
                                databaseName: databaseName,
                                items: dbItems || [],
                                itemCount: dbItems ? dbItems.length : 0,
                                isOwned: isOwned,
                                exists: true,
                                error: null
                            });
                        }
                    }
                };

                try {
                    userbase.openDatabase(options);
                } catch (error) {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        console.log(`Database ${databaseName} access failed: ${error.message}`);
                        resolve({
                            databaseName: databaseName,
                            items: [],
                            itemCount: 0,
                            isOwned: isOwned,
                            exists: false,
                            error: error.message.includes('Database not found') ? 
                                'Database not created yet (normal if feature unused)' : error.message
                        });
                    }
                }
            });
        }

        async function inspectSharedDatabase(dbInfo) {
            const databaseName = dbInfo.databaseName;
            const databaseId = dbInfo.databaseId;
            
            // Extract sender name from database name pattern: shared-contact-{timestamp}-{senderId}-{recipient}
            const matches = databaseName.match(/shared-contact-\d+-([^-]+)-(.+)/);
            const senderName = matches ? matches[1] : 'Unknown';
            
            return new Promise((resolve, reject) => {
                const options = {
                    databaseId: databaseId, // Use databaseId for shared databases
                    changeHandler: (items) => {
                        resolve({
                            databaseName: databaseName,
                            databaseId: databaseId,
                            items: items || [],
                            itemCount: items ? items.length : 0,
                            isOwned: false,
                            exists: true,
                            error: null,
                            senderName: senderName,
                            isShared: true
                        });
                    }
                };

                try {
                    userbase.openDatabase(options);
                } catch (error) {
                    console.log(`Shared database ${databaseName} access failed: ${error.message}`);
                    resolve({
                        databaseName: databaseName,
                        items: [],
                        itemCount: 0,
                        isOwned: false,
                        exists: false,
                        error: error.message,
                        senderName: senderName
                    });
                }
            });
        }

        // Function to inspect localStorage-based databases (like archived received contacts)
        function inspectLocalStorageDatabase(databaseName, config) {
            try {
                console.log(`üîç Inspecting localStorage database: ${databaseName}`);
                
                const items = [];
                const prefix = 'archived-received-';
                
                // Ensure localStorage exists and is accessible
                if (typeof localStorage === 'undefined') {
                    console.warn('localStorage not available');
                    return {
                        databaseName: databaseName,
                        items: [],
                        itemCount: 0,
                        isOwned: config.isOwned || true,
                        exists: false,
                        error: 'localStorage not available',
                        isLocalStorage: true
                    };
                }
                
                console.log(`üîç Looking for localStorage keys with prefix "${prefix}" and user "${currentUser}"`);
                
                // Look for keys that match the archived received contacts pattern
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    console.log(`üîç Checking localStorage key: ${key}`);
                    
                    if (key && key.startsWith(prefix) && key.includes(currentUser)) {
                        console.log(`‚úÖ Found matching key: ${key}`);
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data && typeof data === 'object') {
                                items.push({
                                    itemId: key,
                                    item: data,
                                    createdBy: { 
                                        timestamp: data.archivedAt || new Date().toISOString(), 
                                        username: data.archivedBy || currentUser 
                                    },
                                    updatedBy: { 
                                        timestamp: data.archivedAt || new Date().toISOString(), 
                                        username: data.archivedBy || currentUser 
                                    }
                                });
                                console.log(`‚úÖ Added archived contact: ${data.contactId}`);
                            }
                        } catch (parseError) {
                            console.warn(`Failed to parse localStorage item ${key}:`, parseError);
                        }
                    }
                }
                
                console.log(`üìã Found ${items.length} archived received contacts in localStorage`);
                
                return {
                    databaseName: databaseName,
                    items: items,
                    itemCount: items.length,
                    isOwned: config.isOwned || true,
                    exists: items.length > 0,
                    error: null,
                    isLocalStorage: true
                };
                
            } catch (error) {
                console.error(`‚ùå Error inspecting localStorage database ${databaseName}:`, error);
                return {
                    databaseName: databaseName,
                    items: [],
                    itemCount: 0,
                    isOwned: config.isOwned || true,
                    exists: false,
                    error: error.message,
                    isLocalStorage: true
                };
            }
        }

        function updateLocalStorageSection() {
            const localStorageData = [];
            
            // Check for RFC 9553 contact management related data
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                    (key.startsWith('shared-contact-metadata-') && key.includes(`-${currentUser}`)) ||
                    (key.startsWith('archived-received-') && key.includes(`-${currentUser}`)) ||
                    (key.startsWith('contact-') && key.includes(currentUser)) ||
                    (key.includes('userbase') && key.includes(currentUser))
                )) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        let dataType = 'Unknown Data';
                        
                        if (key.startsWith('shared-contact-metadata-')) {
                            dataType = 'Shared Contact Metadata';
                        } else if (key.startsWith('archived-received-')) {
                            dataType = 'Archived Shared Contact';
                        } else if (key.startsWith('contact-')) {
                            dataType = 'Contact Cache';
                        } else if (key.includes('userbase')) {
                            dataType = 'Userbase Session Data';
                        }
                        
                        localStorageData.push({
                            key: key,
                            type: dataType,
                            data: data
                        });
                    } catch (error) {
                        localStorageData.push({
                            key: key,
                            type: 'Invalid JSON Data',
                            data: localStorage.getItem(key)
                        });
                    }
                }
            }

            let localStorageHtml = `
                <div class="database-section">
                    <h2 class="database-title">üíæ Local Storage Data</h2>
                    <p><em>RFC 9553 Contact Management System data stored locally in browser for user: ${currentUser}</em></p>
            `;

            if (localStorageData.length > 0) {
                localStorageHtml += `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Key</th>
                                <th>Type</th>
                                <th>Data Preview</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${localStorageData.map(item => `
                                <tr>
                                    <td style="font-family: monospace; font-size: 11px; max-width: 200px; word-break: break-all;">${item.key}</td>
                                    <td><span class="contact-type-badge" style="background-color: #17a2b8;">${item.type}</span></td>
                                    <td><pre style="max-height: 100px; overflow-y: auto; font-size: 11px; max-width: 300px;">${typeof item.data === 'object' ? JSON.stringify(item.data, null, 2) : item.data}</pre></td>
                                    <td>
                                        <button class="btn" onclick="deleteLocalStorageItem('${item.key}')" 
                                                style="background-color: #e74c3c; color: white; padding: 5px 8px; font-size: 12px;">
                                            üóëÔ∏è Delete
                                        </button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else {
                localStorageHtml += '<p><em>No RFC 9553 contact management local storage data found for this user</em></p>';
            }

            localStorageHtml += '</div>';
            document.getElementById('localStorageSection').innerHTML = localStorageHtml;
        }

        function deleteLocalStorageItem(key) {
            if (confirm(`Delete local storage item: ${key}?`)) {
                localStorage.removeItem(key);
                updateLocalStorageSection(); // Refresh the section
                alert('Local storage item deleted');
            }
        }

        function clearLocalArchives() {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }

            const keysToDelete = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                    (key.startsWith('shared-contact-metadata-') && key.includes(`-${currentUser}`)) ||
                    (key.startsWith('archived-received-') && key.includes(`-${currentUser}`))
                )) {
                    keysToDelete.push(key);
                }
            }

            if (keysToDelete.length === 0) {
                alert('No local archives or shared contact metadata found for this user');
                return;
            }

            if (confirm(`Clear ${keysToDelete.length} local archive and metadata entries for user ${currentUser}?\n\nThis includes:\n- Shared contact metadata\n- Archived shared contacts\n\nThis action cannot be undone.`)) {
                keysToDelete.forEach(key => localStorage.removeItem(key));
                updateLocalStorageSection();
                alert(`Cleared ${keysToDelete.length} local entries`);
            }
        }

        function updateSummary(total, connected, errors, totalItems) {
            const unavailable = total - connected - errors; // Calculate unavailable count
            
            const summaryHtml = `
                <div class="summary-stats">
                    <div class="stat-card">
                        <div class="stat-number">${total}</div>
                        <div class="stat-label">Total Databases</div>
                    </div>
                    <div class="stat-card" style="background-color: #27ae60;">
                        <div class="stat-number">${connected}</div>
                        <div class="stat-label">Connected</div>
                    </div>
                    ${unavailable > 0 ? `
                        <div class="stat-card" style="background-color: #f39c12;">
                            <div class="stat-number">${unavailable}</div>
                            <div class="stat-label">Unavailable</div>
                        </div>
                    ` : ''}
                    <div class="stat-card" style="background-color: ${errors > 0 ? '#e74c3c' : '#95a5a6'};">
                        <div class="stat-number">${errors}</div>
                        <div class="stat-label">Errors</div>
                    </div>
                    <div class="stat-card" style="background-color: #9b59b6;">
                        <div class="stat-number">${totalItems}</div>
                        <div class="stat-label">Total Items</div>
                    </div>
                </div>
            `;
            document.getElementById('summarySection').innerHTML = summaryHtml;
        }

        function renderDatabaseSections() {
            const container = document.getElementById('databaseSections');
            container.innerHTML = '';

            // Group databases by category
            const categories = {
                owned: [],
                shared: [],
                messaging: [],
                users: [],
                localStorage: [],
                system: []
            };

            Object.entries(allDatabaseData).forEach(([key, dbData]) => {
                const category = dbData.config.category || 'owned';
                categories[category].push([key, dbData]);
            });

            // Render each category
            Object.entries(categories).forEach(([categoryName, databases]) => {
                if (databases.length > 0) {
                    const categoryHeader = document.createElement('h2');
                    categoryHeader.textContent = getCategoryTitle(categoryName);
                    categoryHeader.style.color = '#2c3e50';
                    categoryHeader.style.marginTop = '30px';
                    container.appendChild(categoryHeader);

                    databases.forEach(([key, dbData]) => {
                        const section = document.createElement('div');
                        section.className = 'database-section';
                        section.innerHTML = renderDatabaseSection(key, dbData);
                        container.appendChild(section);
                    });
                }
            });
        }

        function getCategoryTitle(category) {
            const titles = {
                contacts: 'üìá Contact Databases',
                settings: '‚öôÔ∏è Settings & Configuration',
                activity: 'üìä Activity & Audit Logs',
                metadata: 'ÔøΩ Shared Contact Metadata',
                shared: 'ü§ù Shared Databases (Received)',
                localStorage: 'üíæ Local Storage Archives',
                system: '‚öôÔ∏è System Databases'
            };
            return titles[category] || 'üìÅ Other Databases';
        }

        function renderDatabaseSection(key, dbData) {
            const { config, data, status, error } = dbData;
            const statusClass = status === 'connected' ? 'status-connected' : 
                              status === 'unavailable' ? 'status-loading' : 'status-error';
            
            let contentHtml = '';
            
            if (status === 'error' || status === 'unavailable') {
                const errorType = status === 'unavailable' ? 'System database not active' : 'Error';
                contentHtml = `
                    <div class="${status === 'unavailable' ? 'archive-status' : 'error'}">
                        <strong>${errorType}:</strong> ${error || 'Unknown error'}
                    </div>
                `;
            } else if (data) {
                contentHtml = `
                    <div class="database-info">
                        <div class="info-card">
                            <div class="info-label">Database Name:</div>
                            <div>${data.databaseName}</div>
                        </div>
                        <div class="info-card">
                            <div class="info-label">Item Count:</div>
                            <div>${data.itemCount}</div>
                        </div>
                        <div class="info-card">
                            <div class="info-label">Ownership:</div>
                            <div>${data.isOwned ? 'Owned' : 'Shared'}</div>
                        </div>
                        ${data.isShared ? `
                            <div class="info-card">
                                <div class="info-label">Database ID:</div>
                                <div style="font-family: monospace; font-size: 12px;">${data.databaseId}</div>
                            </div>
                        ` : ''}
                    </div>

                    ${data.isShared ? `
                        <div class="shared-db-info">
                            <strong>Shared Database Details:</strong><br>
                            Sender: ${data.senderName}<br>
                            Access: Read-only (recipient cannot modify)
                        </div>
                    ` : ''}

                    ${data.items && data.items.length > 0 ? `
                        <h4>üìã Database Items (${data.items.length})</h4>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Item ID</th>
                                    <th>Type</th>
                                    <th>Created</th>
                                    <th>Updated</th>
                                    <th>Data Preview</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${data.items.map((item, index) => `
                                    <tr>
                                        <td style="font-family: monospace; font-size: 11px;">${item.itemId || 'N/A'}</td>
                                        <td>${generateContactTypeBadges(item.item)}</td>
                                        <td>${item.createdBy ? new Date(item.createdBy.timestamp).toLocaleString() : 'N/A'}</td>
                                        <td>${item.updatedBy ? new Date(item.updatedBy.timestamp).toLocaleString() : 'N/A'}</td>
                                        <td>${generateDataPreview(item.item)}</td>
                                        <td>
                                            <button class="btn" onclick="showFullData('${key}', ${index})" style="padding: 5px 8px; font-size: 12px; margin-right: 5px;">
                                                üëÅÔ∏è View
                                            </button>
                                            ${data.isOwned ? `
                                                <button class="btn" onclick="deleteItem('${key}', '${item.itemId}', ${index})" 
                                                        style="background-color: #e74c3c; color: white; padding: 5px 8px; font-size: 12px;"
                                                        title="Delete this item">
                                                    üóëÔ∏è Delete
                                                </button>
                                            ` : '<span style="font-size: 11px; color: #7f8c8d;">Read-only</span>'}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    ` : '<p><em>No items in this database</em></p>'}
                `;
            }

            return `
                <h2 class="database-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <span class="status-indicator ${statusClass}"></span>
                        ${config.title}
                    </span>
                    ${(status === 'connected' && data && data.itemCount > 0 && data.isOwned) ? `
                        <button class="btn" onclick="deleteDatabase('${key}')" 
                                style="background-color: #e74c3c; color: white; padding: 5px 10px; font-size: 12px;"
                                title="Delete all items from this database">
                            üóëÔ∏è Delete Database
                        </button>
                    ` : ''}
                </h2>
                <p><em>${config.description}</em></p>
                ${contentHtml}
            `;
        }

        function generateContactTypeBadges(item) {
            if (!item) return '';
            
            let badges = [];
            
            // RFC 9553 vCard contact badges
            if (item.vcard) {
                // Check ownership
                if (item.isOwned === false) {
                    badges.push('<span class="contact-type-badge badge-received">Received</span>');
                } else if (item.isOwned !== false) {
                    badges.push('<span class="contact-type-badge badge-owned">Owned</span>');
                }
                
                // Check sharing status
                if (item.sharing && item.sharing.isShared) {
                    badges.push('<span class="contact-type-badge badge-shared">Shared</span>');
                }
                
                // Check archived status
                if (item.isArchived) {
                    badges.push('<span class="contact-type-badge badge-archived">Archived</span>');
                }
                
                // Check favorite status
                if (item.isFavorite) {
                    badges.push('<span class="contact-type-badge" style="background-color: #f39c12;">‚≠ê Favorite</span>');
                }
                
                // Check pinned status
                if (item.isPinned) {
                    badges.push('<span class="contact-type-badge" style="background-color: #e91e63;">üìå Pinned</span>');
                }
                
                return badges.join(' ') || '<span class="contact-type-badge badge-owned">vCard Contact</span>';
            }
            
            // Settings item badges
            if (item.distributionLists && typeof item.distributionLists === 'object') {
                const count = Object.keys(item.distributionLists).length;
                badges.push(`<span class="contact-type-badge" style="background-color: #17a2b8;">‚öôÔ∏è Settings (${count} lists)</span>`);
                return badges.join(' ');
            }
            
            // Activity log badges
            if (item.action && item.timestamp) {
                const actionType = item.action.split('_')[0];
                const badgeColor = {
                    'contact': '#28a745',
                    'share': '#007bff',
                    'archive': '#6c757d',
                    'delete': '#dc3545'
                }[actionType] || '#6c757d';
                
                badges.push(`<span class="contact-type-badge" style="background-color: ${badgeColor};">üìä ${item.action}</span>`);
                return badges.join(' ');
            }
            
            // Shared contact metadata badges
            if (item.sharedContactId && item.sharedBy) {
                badges.push('<span class="contact-type-badge" style="background-color: #6f42c1;">üîó Metadata</span>');
                if (item.isArchived) {
                    badges.push('<span class="contact-type-badge badge-archived">Archived</span>');
                }
                return badges.join(' ');
            }
            
            // Legacy vCardData badges (backward compatibility)
            if (item.vCardData) {
                if (item._receivedContact) badges.push('<span class="contact-type-badge badge-received">Received</span>');
                if (item._sharedByMe) badges.push('<span class="contact-type-badge badge-shared">Shared</span>');
                if (item._archived) badges.push('<span class="contact-type-badge badge-archived">Archived</span>');
                if (!item._receivedContact && !item._sharedByMe) badges.push('<span class="contact-type-badge badge-owned">Owned</span>');
                
                return badges.join(' ') || '<span class="contact-type-badge badge-owned">Legacy Contact</span>';
            }
            
            return '<span style="font-size: 11px; color: #7f8c8d;">Data Item</span>';
        }

        function generateDataPreview(item) {
            if (!item) return 'No data';
            
            // For RFC 9553 vCard contacts
            if (item.vcard) {
                const cardName = item.cardName || 'Unnamed Contact';
                
                // Extract basic info from vCard string
                const vcardLines = item.vcard.split('\n');
                let name = cardName;
                let phone = '';
                let email = '';
                
                for (const line of vcardLines) {
                    if (line.startsWith('FN:')) {
                        name = line.substring(3) || cardName;
                    } else if (line.startsWith('TEL:') || line.includes('TEL;')) {
                        phone = line.split(':').pop() || '';
                    } else if (line.startsWith('EMAIL:') || line.includes('EMAIL;')) {
                        email = line.split(':').pop() || '';
                    }
                }
                
                return `${name}${phone ? ` | ${phone}` : ''}${email ? ` | ${email}` : ''}`;
            }
            
            // For settings database
            if (item.distributionLists && typeof item.distributionLists === 'object') {
                const listCount = Object.keys(item.distributionLists).length;
                return `User settings with ${listCount} distribution lists`;
            }
            
            // For activity logs
            if (item.action && item.timestamp) {
                const action = item.action.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const date = new Date(item.timestamp).toLocaleDateString();
                return `${action} on ${date}`;
            }
            
            // For shared contact metadata
            if (item.sharedContactId && item.sharedBy) {
                const status = item.isArchived ? 'Archived' : 'Active';
                return `Metadata for contact shared by ${item.sharedBy} (${status})`;
            }
            
            // For legacy vCardData contacts (backward compatibility)
            if (item.vCardData) {
                const name = item.vCardData.fn || item.cardName || 'Unnamed';
                const phone = item.vCardData.tel ? (Array.isArray(item.vCardData.tel) ? item.vCardData.tel[0] : item.vCardData.tel) : '';
                const email = item.vCardData.email ? (Array.isArray(item.vCardData.email) ? item.vCardData.email[0] : item.vCardData.email) : '';
                
                return `${name}${phone ? ` | ${phone}` : ''}${email ? ` | ${email}` : ''}`;
            }
            
            // For other data, generate a brief preview
            const preview = {};
            let count = 0;
            
            for (const [key, value] of Object.entries(item)) {
                if (count >= 3) break;
                if (key.startsWith('_')) continue; // Skip internal properties
                
                if (typeof value === 'string' && value.length > 30) {
                    preview[key] = value.substring(0, 30) + '...';
                } else {
                    preview[key] = value;
                }
                count++;
            }
            
            return JSON.stringify(preview, null, 1).substring(0, 100) + '...';
        }

        function showFullData(databaseKey, itemIndex) {
            const item = allDatabaseData[databaseKey].data.items[itemIndex];
            
            const newWindow = window.open('', '_blank', 'width=800,height=600');
            newWindow.document.write(`
                <html>
                <head>
                    <title>Full Item Data</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .json-container { background: #2c3e50; color: #ecf0f1; padding: 20px; border-radius: 6px; overflow: auto; }
                        pre { white-space: pre-wrap; word-wrap: break-word; }
                        .header { background: #34495e; color: white; padding: 15px; margin-bottom: 20px; border-radius: 6px; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>Full Item Data</h1>
                        <p><strong>Database:</strong> ${allDatabaseData[databaseKey].config.title}</p>
                        <p><strong>Item ID:</strong> ${item.itemId || 'N/A'}</p>
                    </div>
                    <div class="json-container">
                        <pre>${JSON.stringify(item, null, 2)}</pre>
                    </div>
                </body>
                </html>
            `);
        }

        async function deleteItem(databaseKey, itemId, itemIndex) {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }

            const dbData = allDatabaseData[databaseKey];
            if (!dbData || !dbData.data) {
                alert('Database not found or no data available');
                return;
            }

            const databaseName = dbData.data.databaseName;
            const item = dbData.data.items[itemIndex];

            if (!item) {
                alert('Item not found');
                return;
            }

            const itemPreview = generateDataPreview(item.item);
            const confirmed = confirm(
                `‚ö†Ô∏è Delete this item from "${dbData.config.title}"?\n\n` +
                `Database: ${databaseName}\n` +
                `Item ID: ${itemId}\n` +
                `Data: ${itemPreview}\n\n` +
                `This action cannot be undone. Are you sure?`
            );

            if (!confirmed) return;

            try {
                await userbase.deleteItem({
                    databaseName: databaseName,
                    itemId: itemId
                });

                alert(`‚úÖ Successfully deleted item ${itemId}`);

                // Update the current database data
                if (allDatabaseData[databaseKey] && allDatabaseData[databaseKey].data) {
                    allDatabaseData[databaseKey].data.items.splice(itemIndex, 1);
                    allDatabaseData[databaseKey].data.itemCount = allDatabaseData[databaseKey].data.items.length;
                }

                renderDatabaseSections();

            } catch (error) {
                console.error(`‚ùå Error deleting item ${itemId}:`, error);
                alert(`‚ùå Error deleting item: ${error.message}`);
            }
        }

        async function deleteDatabase(databaseKey) {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }

            const dbData = allDatabaseData[databaseKey];
            if (!dbData || !dbData.data || !dbData.data.isOwned) {
                alert('Database not found, no data available, or not owned by you');
                return;
            }

            const databaseName = dbData.data.databaseName;
            const itemCount = dbData.data.itemCount;

            const confirmed = confirm(
                `‚ö†Ô∏è WARNING: This will permanently delete all ${itemCount} items from database "${databaseName}".\n\n` +
                `Database: ${dbData.config.title}\n` +
                `Items to delete: ${itemCount}\n\n` +
                `This action cannot be undone. Are you sure?`
            );

            if (!confirmed) return;

            try {
                const items = dbData.data.items || [];
                if (items.length === 0) {
                    alert('No items to delete');
                    return;
                }

                let deletedCount = 0;
                const errors = [];

                for (const item of items) {
                    try {
                        await userbase.deleteItem({
                            databaseName: databaseName,
                            itemId: item.itemId
                        });
                        deletedCount++;
                    } catch (error) {
                        errors.push(`${item.itemId}: ${error.message}`);
                    }
                }

                if (errors.length === 0) {
                    alert(`‚úÖ Successfully deleted all ${deletedCount} items from ${databaseName}`);
                } else {
                    alert(`‚ö†Ô∏è Deleted ${deletedCount} items, but ${errors.length} failed:\n\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}`);
                }

                // Update the current database data
                if (allDatabaseData[databaseKey] && allDatabaseData[databaseKey].data) {
                    allDatabaseData[databaseKey].data.items = [];
                    allDatabaseData[databaseKey].data.itemCount = 0;
                }

                renderDatabaseSections();

            } catch (error) {
                console.error('Error deleting database items:', error);
                alert(`‚ùå Error deleting database items: ${error.message}`);
            }
        }

        async function refreshAllData() {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }
            
            await inspectAllDatabases();
        }

        async function refreshAllData() {
            console.log('üîÑ Force refresh initiated...');
            
            // Show loading state
            document.getElementById('refresh-btn').innerHTML = '‚è≥ Refreshing...';
            document.getElementById('refresh-btn').disabled = true;
            
            // Clear existing data
            window.databaseResults = [];
            allDatabaseData = [];
            
            // Show loading in summary
            const summaryDiv = document.getElementById('summary');
            if (summaryDiv) {
                summaryDiv.innerHTML = '<div class="summary-item">üîÑ <strong>Refreshing all databases...</strong></div>';
            }
            
            try {
                // Re-run full inspection (this includes database discovery)
                await inspectAllDatabases();
                console.log('‚úÖ Force refresh completed successfully');
            } catch (error) {
                console.error('‚ùå Force refresh failed:', error);
                alert(`Refresh failed: ${error.message}`);
            } finally {
                // Reset button state
                document.getElementById('refresh-btn').innerHTML = 'üîÑ Force Refresh';
                document.getElementById('refresh-btn').disabled = false;
            }
        }

        function exportAllData() {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }
            
            const exportData = {
                user: currentUser,
                timestamp: new Date().toISOString(),
                version: 'rfc-9553-contact-management',
                databases: allDatabaseData,
                discoveredDatabases: discoveredDatabases,
                localStorage: getLocalStorageData()
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `database-export-rfc9553-${currentUser}-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getLocalStorageData() {
            const localData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (key.includes(currentUser) || key.startsWith('contact-') || key.startsWith('archived-') || key.startsWith('shared-'))) {
                    try {
                        localData[key] = JSON.parse(localStorage.getItem(key));
                    } catch (error) {
                        localData[key] = localStorage.getItem(key);
                    }
                }
            }
            return localData;
        }

        // Auto-login if user is already signed in
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                if (navigator.userAgent.includes('Firefox')) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                await userbase.init({ appId: '77e5016f-285d-4678-a31a-3718479a638a' });
                
                setTimeout(async () => {
                    try {
                        let currentSessionUser = null;
                        
                        if (typeof userbase.getSession === 'function') {
                            currentSessionUser = await userbase.getSession();
                        }
                        
                        if (currentSessionUser && currentSessionUser.username) {
                            console.log('Found existing session for user:', currentSessionUser.username);
                            currentUser = currentSessionUser.username;
                            document.getElementById('loginSection').style.display = 'none';
                            document.getElementById('inspectorContent').style.display = 'block';
                            await inspectAllDatabases();
                        } else {
                            console.log('No existing session found, showing login form');
                        }
                    } catch (error) {
                        console.log('No existing session found:', error.message);
                    }
                }, 500);
                
            } catch (error) {
                console.log('Error initializing userbase:', error.message);
            }
        });
    </script>
</body>
</html>
